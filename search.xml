<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图]]></title>
    <url>%2F2019%2F08%2F01%2F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图图的存储图是由点集和边集构成。但实际存储时，我们只存边的信息。 存储方式 邻接表（查找时间复杂度高） 邻接矩阵（空间复杂度高，造成较大的浪费；查找时间复杂度为O(1)） 链式前向星（本质是邻接表） 邻接表是不好写但效率高，邻接矩阵是好写但效率不高，前向星是一个相对中庸的数据结构。前向星固然好，但效率不高。而在优化为链式前向星后，效率得到了较大的提升。 链式前向星 链式前向星结构 结构体数组edge存储边的信息，edge[i]表示第i条边。 head[i]存以i为起点的第一条边在edge结构体数组中的下标位置。 12345678struct Edge&#123; int next; //下一条边的存储下标（默认为0） int to; //这条边的终点 int w; //权值&#125;;Edge edge[MAX_M + 5]; //根据图的边数来开空间int head[MAX_N + 5]; //根据图的点数来开head数组的空间，因为head数组表示以i点为起点的边。int cnt = 0; 增边因为链式前向星的本质是邻接表，在edge数组中我们也可以看出是靠next来索引同一起点的边。所以增边的操作其实就是链表的头插法。 123456void add(int a, int b, int c) &#123; edge[++cnt].to = b; edge[cnt].next = head[a]; edge[cnt].w = c; head[a] = cnt;&#125; 遍历操作遍历以st为起点的边 123for(int i = head[st]; i != 0; i=edgr[i].next) &#123; cout &lt;&lt; "...." &lt;&lt; endl;&#125; 图的最短路问题 单源最短路问题。（从某一点（源点）到其他所有各顶点的最短路径长度） 多源最短路问题。（求得任意两点之间的最短路径） 图的单源最短路算法Dijkstra算法其主要特点是以起始点为中心向外层层扩展，直到扩展了所有的点；其是一种按路径长度递增的次序产生最短路径的算法。 注意该算法要求图中不含负权边。是因为该算法的正确性是由最短路径是其按路径长度递增的次序产生的，而存在负边的情况就不能保证当前所找的路径一定小于以后新加入点扩展出的路径短（存在负边的原因），这就不能保证算法的正确性了。 #### 原理 - 对于图$G=(V,E)$，将G中的顶点分成两组： - 第一组S：已求出最短路径的终点集合（初始时只包含源点$v_0$）。 - 第二组V-S：尚未求出的最短路径的顶点集合（初始时为$V-v_0$）。 - 算法将按照各顶点与$v_0$间最短路径的长度递增的次序，逐个将集合$V-S$中的顶点加入到集合S中去。在这个过程中，总保持从$v_0$到集合S中各顶点的路径长度始终不大于到集合$V-S$中个各顶点的路径长度。 - 算法的实现需要借助三个数据结构 - 一维数组S：记录从源点$v_0$到终点$v_i$是否已被确定最短路径长度。如已确定用true表示；否则用false表示尚未确定。 - 一维数组Path：记录从源点$v_0$到终点$v_i$的当前最短路径上$v_i$的直接前驱顶点序号。其初始值为：如果$v_i$与$v_0$有弧，则Path[i]为$v_0$；否则为-1。 - 一维数组D：记录从源点$v_0$到终点$v_i$的当前最短路径长度。其初值为：如果$v_i$与$v_0$有弧，则D[i]为弧上的权值；否则为无穷大。 - 每当从当前的数组D中挑选出最短路径，将其终点$v_i$加入集合S；对第二组中剩余的各顶点来说，从源点$v_0$到该集合中的点多了一个“中转”顶点，从而多了一个"中转"的路径，所要对第二组中剩余的各顶点的最短路径长度进行更新。 - 原来$v_0$到$v_i$的最短路径长度是D[i]，加入$v_k$之后，以$v_k$作为中间顶点的"中转"路径长度为：$D[k]+G.arcs[k][i]$，若：$D[k]+G.arcs[k][i] < D[i]$的话就进行更新，否则不更新。 - 更新后，再选择数组D中值最小的顶点加入集合S中，如此进行下去，知道图中的所有顶点都加入到第一组顶点集合S中。 #### 实现 最基础的实现，时间复杂度$O(n^2)$ `洛谷3371 AC代码` 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define MAX_N 10000#define MAX_M 500000#define INF 0x3f3f3f3fstruct Edge &#123; int next; int to; int w;&#125;;Edge edge[MAX_M + 5];int head[MAX_N + 5] = &#123;0&#125;, cnt = 0;int vis[MAX_N + 5] = &#123;0&#125;, dis[MAX_N + 5];//0编号位不用来存储，作为结束标识为。inline void add(int a, int b, int c) &#123; edge[++cnt].to = b; edge[cnt].next = head[a]; edge[cnt].w = c; head[a] = cnt;&#125;void dij(int s, int n) &#123; memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; for (int i = 1; i &lt; n; i++) &#123; //遍历d数组，找到当前数组中的最短路径 int ind = -1; for (int j = 1; j &lt;= n; j++) &#123; if (vis[j]) continue; if (ind == -1 || dis[ind] &gt; dis[j]) ind = j; &#125; vis[ind] = 1; //查看新加入的点能否更新其他未确定最短路径的点距离。 for (int j = head[ind]; j; j = edge[j].next) &#123; if (!vis[edge[j].to] &amp;&amp; dis[ind] + edge[j].w &lt; dis[edge[j].to]) &#123; dis[edge[j].to] = dis[ind] + edge[j].w; &#125; &#125; &#125;&#125;int main() &#123; int n, m, s; int a, b, c; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; while(m--) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; dij(s, n); for (int i = 1; i &lt;= n; i++) &#123; i == 1 || cout &lt;&lt; " "; if (dis[i] == INF) &#123; cout &lt;&lt; 2147483647; &#125; else &#123; cout &lt;&lt; dis[i]; &#125; &#125; return 0;&#125; > $inline$声明为内联函数，当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插入调用语句处，就行整个函数体在调用处被重写了一遍一样。 > 因此有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，但不需要付出执行函数调用的额外开销。很显然，使用内联函数会使最终的可执行程序的体积增加，以空间换时间。 #### 优化 $O(V^2)$的时间复杂度显然能够进行优化，主要是对每次从D数组中找寻当前最短路径时的一个优化。这里我们借助C++中的优先队列来进行优化。 > 优先队列，具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质上是堆实现的。 > > 在优先队列中，元素被赋予优先级。当访问元素时，优先级高的排在队列前面，优先出队，最先被删除。优先队列具有最高级先出的行为特征。 > > 定义：priority_queue。Type就是数据类型，Container是容器类型（Container必须是数组实现的容器，比如vector等，但不能用list。STL中默认是vector），functional就是比较的方式。 > > 当需要使用自定义数据类型是，才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。 123456//基础类型，默认是大顶堆priority_queue&lt;int&gt; a;//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;//小顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; c; 同时，对于其不能处理负权边的情况也能改进：当某个点的最短距离被更新，那么就将其标记值重置为false。这样就能适用于带负权边的图。 检验 洛谷4779 AC代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;#define MAX_N 100000#define MAX_M 200000struct Edge&#123; int next; int to; int w;&#125;;Edge edge[MAX_M + 5];int head[MAX_N + 5], cnt = 0;int vis[MAX_N + 5] = &#123;0&#125;, dis[MAX_N + 5];//一个表示最短路径终点的to和该路径的最短长度wstruct Data&#123; int to; int w; Data(int a, int b): to(a), w(b) &#123;&#125; //重载运算符，路径短的元素反而大，这样在定义优先队列时，就可直接使用默认的大根堆。 bool operator&lt;(const Data &amp;obj) const &#123; return this-&gt;w &gt; obj.w; &#125;&#125;;inline void add(int a, int b, int c) &#123; edge[++cnt].to = b; edge[cnt].next = head[a]; edge[cnt].w = c; head[a] = cnt;&#125;void dij(int s, int n) &#123; memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; priority_queue&lt;Data&gt; q; q.push(Data(s, 0)); for (int i = 1; i &lt; n; i++) &#123; int ind = q.top().to; q.pop(); //这一块应该是防止什么特殊情况，我还没想明白 while (vis[ind] &amp;&amp; !q.empty()) &#123; ind = q.top().to; q.pop(); &#125; for (int j = head[ind]; j; j = edge[j].next) &#123; if (dis[edge[j].to] &gt; dis[ind] + edge[j].w) &#123; dis[edge[j].to] = dis[ind] + edge[j].w; q.push(Data(edge[j].to, dis[edge[j].to])); &#125; &#125; vis[ind] = 1; &#125;&#125;int main() &#123; int n, m, s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; int a, b, c; while (m--) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; dij(s, n); for (int i = 1; i &lt;= n; i++) &#123; i == 1 || cout &lt;&lt; " "; cout &lt;&lt; dis[i]; &#125; cout &lt;&lt; endl; return 0;&#125; 因为面试单源最短路主要考察dijkstra，故此处先整理该算法。至于单源最短路的Bellman-ford算法和基于其改进的SPFA算法日后再补充。 图的多源最短路算法Floyd算法用于解决多源最短路问题，即求解图中每一对顶点间的最短路问题。该算法适用于无负环有向图或无向图的多源最短路问题。 实现时，使用邻接矩阵存图，时间复杂度为$O(n^3)$，空间复杂度为$O(n^2)$。 原理$floyd$算法是利用动规的思想设计实现的。我们考虑决定最短路径的信息时可发现，起点、终点和到达这两点之间所经过的所有点决定着这个路径的长度。 $floyd$算法就是利用这三维来表示动规状态。$dp(k,i,j)$代表从i点到达j点，经过前k个点的最短路径长度。状态转移方程如下： dp(k, i, j) = min\begin{cases} dp(k-1, i, j) \ 不经过k点的路径 \\ dp(k-1, i, k) + dp(k-1, k, j) \ 经过k点的路径 \\ \end{cases} 我们观察dp方程可发现，状态k的结果只取决于k-1时的状态。所以在实际实现时，不需要建立三维数组，利用for循环更新二维数组代替k这一维，更新前二维数组存储的值是状态k-1时的值，更新后就是状态k下的值了。 所以代码中k这一维实际不存在，但是逻辑上却是存在的。 洛谷 P2910 AC代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int arr[10005];int dp[105][105];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; arr[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; dp[i][j]; &#125; &#125; /* 第一层循环表示遍历所有点，因为任意起点和终点之间可能经过很多中间点的跳转能缩小距离，并且每增加一个点的跳转是在上一点的跳转基础上，所以它得是最外层循环。通俗的说，这n轮循环就是：i,j之间经过1号点中转距离会不会发生变化；经过1和2号点中转距离会不会变化； 经过1、2、3点中转距离会不会变化…… */ for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]); &#125; &#125; &#125; int ans = 0; for (int i = 0 ; i &lt; m-1; i++) &#123; ans += dp[arr[i]][arr[i + 1]]; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>graph</tag>
        <tag>最短路算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229(四) - logistic Regression]]></title>
    <url>%2F2019%2F05%2F03%2Fml4-logisticRegression%2F</url>
    <content type="text"><![CDATA[虽然$Logistic \ Regression$算法的名字中含有$Regression$ 。但它却是一个分类算法，而不是一个线性回归算法。 一、假设函数逻辑回归模型的假设函数： h_\theta(x)=g(\theta^Tx)\\ g(z)=\frac{1}{1+e^{-z}}\\ h_\theta(x) = \frac{1}{1+e^{\theta^{T}x}}\\ 0\le h_\theta(x) \le 1$sigmoid/logistic$函数：$g(z)=\frac{1}{1+e^{-z}}$。就是由于该函数的特性，保证了假设函数的输出在$0,1$之间。假设函数的输出值表示：当输入值为x时，y=1的概率；$h_\theta(x)=P(y=1|x;\theta)$。 决策边界（Decision Boundary)根据假设函数的输出定义，当$h\theta(x) \ge0.5 $时，我们就预测$y=1$；当$h\theta(x) \lt 0.5$时，我们就预测$y=0$（对于0.5的情况，并没有强制性的规定，即可归为正类，也可归为负类）。 再结合$sigmoid$函数的特性可知，当$z\ge0$时，$h\theta(x) \ge0.5 $，$y=1$；当$z\lt0$时，$h\theta(x) \lt0.5 $，$y=0$。所以在类别判断时，我们只需要判断自变量（$\theta^Tx$）的取值就行了。 举例 例如假设函数为：$h_\theta(x) = g(\theta_0+\theta_1x_1+\theta_2x_2+\theta_3x_1^2+\theta_4x_2^2)$，同时假设已经计算出$\theta_0=-1，\theta_1=0，\theta_2=0，\theta_3=1，\theta_4=1$。根据上述结论，我们可知：当$-1+x_1^2+x_2^2 \ge 0$时，我们可以预测$y=1$；当$-1+x_1^2+x_2^2 \lt 0$时，我们可以预测$y=0$。 所以$x_1^2+x_2^2 = 1$就是决策边界。 $ps：$由此，我们可以看出决策边界是假设函数的一个属性，与数据集无关。只要假设函数中的变量$\theta$确定了，那么决策边界也就随之确定了。 二、代价函数在之前的线性回归模型中，我们的代价函数是使用误差平方和的形式来表示。但是在逻辑回归模型中，假设函数$h_\theta(x)=\frac{1}{1+e^{-\theta^{T}x}}$是一个较为复杂的非线性函数，直接代入的话得到的代价函数就不是一个关于参数$\theta$的凸函数。无法采用梯度下降来找到全局最优解。 所以需要构造合适的代价函数： J(\theta)=\frac{1}{m}\sum_{i=1}^{m}{Cost(h_\theta(x^{i}),y^{i})} \\ \\ Cost(h_\theta(x), y) = \begin{cases} -log(h_\theta(x))\quad if\ y=1\\ -log(1-h_\theta(x))\quad if \ y =0 \end{cases}\\ \\ Note:y = 0\ or\ 1\ always我们所选择的这个代价函数是从统计学中的极大似然法得来的。它是统计学为不同模型中快速寻找参数的方法，同时他还有一个很好的特性，就是是凸函数。 $Cost(h\theta(x), y) $函数图像如下所示。由图我们可以看出，当$y=1，h\theta(X)=1$时，函数值为0；$y=1，h_\theta(X)=0$时，函数值趋于正无穷。$y=0$时类似。 三、梯度下降在逻辑回归模型中最小化代价函数的方法依然是梯度下降。 为了便于梯度下降算法的执行，我们需要将代价函数稍做整理： Cost(h_\theta(x), y) = -ylog(h_\theta(x))-(1-y)log(1-h_\theta(x))最终得到$Logistic\ Regression\ cost \ function :$ J(\theta)=\frac{1}{m}\sum_{i=1}^{m}{Cost(h_\theta(x^{(i)},y^{i})}\\ =-\frac{1}{m}[\sum_{i=1}^{m}{y^{(i)}log(h_\theta(x^{i})+(1-y^{(i)})log(1-h_\theta(x^{(i)}))}]$Want\ min_{\theta}J(\theta):$ Repeat\ \{ \\ \theta_j :=\theta_j-\alpha\frac{\partial}{\partial \theta_j}J(\theta)\\ that's\ mean:\\ \theta_j:=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^m{h_\theta(x^{(i)}-y^{(i)})x_j^{(i)}}\\ \}经过计算，我们惊讶地发现$logistic$的梯度下降算法公式与线性回归中的梯度下降下降算法公式一致。但是我们要知道，线性回归和$logistic$的假设函数是不一样的，只是更新的规则类似。 同时，在$logistic$算法中，我们采用与线性回归相同的方法来监测梯度下降，以确保其正常收敛，在梯度下降时采用的特征缩放同样也适用。 四、高级优化算法除了梯度下降算法还有其他更加高级更加复杂的算法：共轭梯度、BFGS、L-BFGS。相比于梯度下降，这些方法能大幅提升$logistic$算法的执行速度，也更加适合解决大型的机器学习问题。 其优点： 不需要手动选择学习率$\alpha$ 智能内循环算法—-线搜索算法：可以自动地尝试不同的学习率并自动选择一个恰当的学习率，甚至可以为每次迭代选择一个学习率。 收敛地远快于梯度下降。 12345678910111213141516function [jVal, gradient] = costFunction(theta)%----return the cost function and the gradient----% jVal = [code to compute J(theta)];gradient(1) = [code to compute theta(0) partial derivative]gradient(2) = [code to compute theta(1) partial derivative]...gradient(n+1) = [code to compute theta(n) partial derivative]end%------------------------------------------------------%options = optimest('GradObj','on','MaxIter','100');initialTheta = zeros(n,1);[optTheta, functionVal, exitFlag] = fminunc(@costFunction,initialTheta,options);%exitFlag用来判断该算法是否收敛%fminunc高级优化函数，表示无约束最小化函数 五、多类别分类问题一对多的分类算法即将多分类问题分成多个二分类问题来解决。 原理 训练一个逻辑回归分类器$h_\theta^{(i)}(x)$预测$i$类别$y=i$的概率。 预测时，取$h_\theta^{(i)}(x)$中的最大值，其对应的分类即为预测的分类。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>logistic Regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture16]]></title>
    <url>%2F2019%2F05%2F02%2FLecture16%2F</url>
    <content type="text"><![CDATA[Lecture 16一、模板语法 vue使用了基于HTML的模板语法，声明式地将DOM绑定至Vue实例的数据。在底层的实现上，Vue 将模板编译成虚拟DOM渲染函数。结合响应系统智能地计算出最少需要重新渲染的组件，把DOM 操作次数减到最少。 1. Text数据绑定使用双大括号的文本插值。标签将会被替代为绑定值，当绑定数据发生改变，插值出的内容将自动更新。 2. Using JavaScript Expressions对于所有的数据绑定，Vue提供了完全的JavaScript表达式支持，表达式会作为JavaScript解析。 3. Computed Properties模板内的表达式虽然便利，但在模板内放入太多的逻辑会让模板过重而且难以维护。模板应该仅提供简单的声明式逻辑。因此对于复杂的逻辑，应当使用计算属性。 computed属性中可以声明若干“方法”，在模板中直接声明绑定计算属性，当绑定的数据改变时，自动重新计算。 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; //计算属性依赖的数据 &#123;&#123; message &#125;&#125; &lt;br /&gt; //绑定计算属性 &#123;&#123; reversMessage &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data: () =&gt; (&#123; message: "hello" &#125;), //复杂的逻辑，使用计算属性 computed: &#123; reversMessage() &#123; //只有计算属性的相关依赖发生改变时，缓存了结果，才会重新求值。 return this.message .split("") .reverse() .join(""); &#125; &#125;&#125;&lt;/script&gt; 声明的计算”方法”必须具有返回值（自动声明/绑定属性的getter方法）即，reversMessage应作为属性而非方法使用。所以计算属性本身不是函数，不接受参数。但是属性的值，可以是一个函数！而函数自然可以接受参数。 12345678910111213141516&lt;span&gt; &#123;&#123; formatDate(h.deadline) &#125;&#125; &lt;/span&gt;&lt;script&gt;export default &#123; computed: &#123; //computed属性的值为返回一个函数，将参数传递给属性返回的函数。函数操作计算后将结果返回 formatDate()&#123; return date =&gt; date.replace("T", " "); &#125; /*这是错误的写法，因为fomatDate()是计算属性，而不是方法，不能接受参数 formatDate(date)&#123; return date.replace("T", " "); &#125; */ &#125;&#125;&lt;/script&gt; 因此应仅应用于处理模板显示信息不能用于网络请求等异步操作。 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &#123;&#123; user.insertTime &#125;&#125; &lt;br /&gt; //绑定经过处理的计算属性 &#123;&#123; myDate &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data: () =&gt; (&#123; //标准的从数据库提取转为LocalDateTime Jackson序列化的ISO时间 user: &#123; name: "BO", insertTime: "2019-04-25T11:04:25" &#125; &#125;), computed: &#123; myDate() &#123; return this.user.insertTime.replace("T", " "); &#125;, &#125;&#125;&lt;/script&gt; 由于JS的限制，Vue不能自动检测（数据虽然改变，但是非响应式，即模板不会自动更新）以下变动的数组： 利用索引直接设置一个项 修改数组的长度 在已引用的对象上增加属性 二、Router Passing Parameter基于RESTful的参数传递。 在router.js路由中，使用:参数名，声明参数变量（类似）。 1path: "/example05/students/:sid/homeworks/:hid" 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;h1&gt;Router Passing Paramter&lt;/h1&gt; student ID: &#123;&#123; $router.params.sid &#125;&#125; &lt;br /&gt; homework ID: &#123;&#123; $router.params.hid &#125;&#125; &lt;br /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; create() &#123; //路由参数会被置于，this.$route.params，基于路由参数名称获取参数值。 console.log(this.$route.params.sid); console.log(this.$route.params.hid); &#125; &#125;&lt;/script&gt; 当路由前后2次，切换的是同一组件时（只是组件中的内容改变），组件默认会被直接复用，因此不会触发生命周期回调函数。 但是我们有时需要在create函数中调用某些方法实行不同内容的渲染。解决办法：通过v-bind指令在router 三、Directives(指令) 指令(Directives)，是带有v-前缀的特殊特性。 指令特性值，预期是单个JavaScript表达式，需要附着于标签（HTML元素） 指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM。 模板语法类似于EL表达式，vue指令类似于JSTL标签库，两者结合即可动态的显示数据。 1. V-text更新元素的textContent。如果需要更新部分textContent，使用 {{ }} 插值。 123456//----------------------------&lt;span v-text="msg"&gt;&lt;/span&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;//---上述两者实现的效果是一致的---//---部分更新内容------&lt;span&gt;hello &#123;&#123; username &#125;&#125;&lt;/span&gt; 2. v-if；v-else；v-else-if 这几个指令都是根据表达式的值的真假条件渲染元素。 如果切换的过程包含多个元素，而又无法声明div等元素包裹，可以使用\等元素作为不可见的包裹元素。因为\元素无任何显示效果。 12345&lt;template v-if="isUserNameLogin"&gt; &lt;input placeholder="enter you name" /&gt; &lt;br /&gt; &lt;input type="password" placeholder="enter you password" /&gt;&lt;/template&gt; 组件复用vue会尽可能高效地渲染元素，通常会复用已有元素，而不是重新创建。遂可提高Vue的渲染速度，同时复用元素的属性值。 123456789101112131415&lt;template v-if="isUserNameLogin"&gt; &lt;input placeholder="enter you name" /&gt; &lt;br /&gt; &lt;input type="password" placeholder="enter you password" /&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;input placeholder="enter you key" /&gt;&lt;/template&gt;//--------------methods: &#123; changeInput() &#123; this.isUserNameLogin = !this.isUserNameLogin; &#125;&#125; 如以上代码中所展示的，当由if时的情况切换到else时的情况时，else中的那个input直接复用if中的第一个输入框，仅更新placeholder属性。而不是另外再创建一个输入框。 消除组件复用通过key属性声明唯一性，使组件不被复用。 12345678&lt;template v-if="isUserNameLogin"&gt;&lt;input placeholder="enter you name" key="username"/&gt;&lt;br /&gt;&lt;input type="password" placeholder="enter you password" /&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;input placeholder="enter you key" key="key"/&gt;&lt;/template&gt; 此时切换时，input不会被复用。 3. v-show与v-if不同，元素始终会被渲染并保留在DOM中。v-show只是简单地通过修改元素display属性实现显示/隐藏。 v-if与v-show v-if是真正的条件渲染，它会确保在切换过程中条件块内的组件适当地被销毁和重建。 v-if，如果在初始渲染时条件为假，则什么也不做，直到条件第一次变真时渲染条件块。 v-show，不管初始条件，元素总是会被渲染（代码中显示该组件元素），并且只是简单地基于CSS进行切换。 v-if有更高的切换开销，而v-show有更高的初始渲染开销。因此，如果需要非常频繁地切换，使用v-show较好；如果在运行时条件很少改变，则使用v-if较好。 4. v-bind动态绑定html标签属性的表达式。可缩写，例如：V-bind:key，可缩写为:key。 1234567891011&lt;button v-bind:disabled="enabled" @click="setAgree"&gt;提交&lt;/button&gt;/*-------------------------------------------*/&lt;script&gt;export default &#123; methods: &#123; setAgree() &#123; this.enabled = !this.enabled; &#125; &#125;&#125;&lt;/script&gt; 5. v-for根据一组数组的选项列表进行渲染。需要使用item in items形式的特殊语法，items是源数据数组并且item是数组元素迭代的别名。 1234567891011121314151617&lt;ul&gt;//在v-for中必须绑定key属性至唯一id，从而跟踪每个节点的身份，重用和重排序现有元素。 &lt;li v-for="h in homeworks" v-bind:key=h.id"&gt; &lt;rouer-link v-bind:to="'/homeworks/' + h.id"&gt; &#123;&#123; h.name &#125;&#125; / &#123;&#123; h.deadline &#125;&#125; &lt;/router-link&gt; &lt;/li&gt;&lt;/ul&gt;/*---------------------------*/data: () =&gt; (&#123; homeworks: [ &#123;id: 1, name: "Java基本数据类型"， deadline: "2018-04-29T20:00"&#125;, &#123;id: 2, name: "Java封装"， deadline: "2018-04-29T20:00"&#125;, &#123;id: 3, name: "Java泛型"， deadline: "2018-04-29T20:00"&#125; ] &#125;) 四、模板字符串 模板字符串，允许嵌入表达式的字符串字面量。 模板字符串使用反引号(``)，代替普通字符串的双引号和单引号。 模板字符串可以包含特定语法，${}占位符。占位符中的表达式与文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来。 123/*------原始拼接方式和模板字符串方式比较-------*/v-bind:to="'/homworks/' + h.id"v-bind:to="`/homworks/$&#123;h.id&#125;`"]]></content>
      <categories>
        <category>System Design</category>
      </categories>
      <tags>
        <tag>Template Syntax</tag>
        <tag>Computed Properties</tag>
        <tag>Directives</tag>
        <tag>Template String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture15]]></title>
    <url>%2F2019%2F05%2F01%2FLecture15%2F</url>
    <content type="text"><![CDATA[Lecture 15一、Vue工程结构介绍 node_modules，npm install命令按配置下载的依赖。 public，公共静态资源目录。 src，项目源码。 assets，项目局部资源文件目录，基于配置编译。例如将图片编译为base64编码的字符串。 components，Vue组件，其下包含的是与业务逻辑无关的组件。例如，登录错误提醒等 views，视图组件目录。 App.vue，页面默认根组件。包含HTML 、JS、CSS代码的基本vue组件。 main.js，webpack打包入口文件。 router.js，vue路由设置。 .browserslistrc，babel浏览器兼容性范围。 .eslintrc.js，eslint的配置文件。 .gitignore，Git忽略配置。 babe.config.js，babel配置文件。 package-lock.json，安装时项目的全部依赖配置声明。 package.json，项目配置，类似pox.xml。 为了减少源文件（JS CSS文件）的大小或合并源文件减少HTTP请求，需要将源文件编译。编译后的JS文件，使用了极简名称替换了源文件中的变量、方法、参数等等的名称，极大的减少了文件的尺寸。 .map文件，存放源码和编译后代码的关系映射文件，包括源文件、行号、列号或变量名的映射关系。 vue工程经过webpack打包后形成css、img、js三个文件夹以及index.html，favicon.ico。 二、组件(Components) 组件是Vue.js最强大的功能之一。组件可以扩展HTML元素，封装可重用的代码。 所有Vue组件同时也是Vue的实例（类Vue创建出的对象），所以可接受相同的选项对象，并提供相同的生命周期回调方法。 components与views的区别 components，业务逻辑无关的封装可复用的组件，例如全局警告框等。 Views，具体的视图组件。 在较高层面，组件是自定义元素，Vue.js的编译器为它添加特殊功能。 在默认配置不能满足项目需求时，在项目根目录创建vue.config.js配置文件 1. 全局注册1234567891011121314151617181920212223//main.js文件//引入Vue，App组件，路由模块文件import Vue from "vue";import App from "./App.vue";import router from "./router";/*创建一个Vue对象将Vue对象挂载到页面#app节点----Index.html----&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;----App组件--------&lt;template&gt; &lt;div id="app"&gt; &lt;siderbar /&gt; &lt;router-view /&gt; &lt;/div&gt;&lt;/template&gt;*/new Vue (&#123; router, render: h =&gt; h(App)&#125;).$mount("#app"); **app.vue组件，为应用根组件；其他组件，为其子组件。因此，全局仅注册app组件，其他组件局部注册即可。** ES6规范，所有.vue文件，js，css，图片等均为模块。通过import关键字引入。 2. 基本vue组件内容 组件模板内只能有一个根root。即，内容必须在1个div之内。 组件的默认输出。export default{ } 组件样式。Scoped属性，为仅组件内有效样式，非全局，不影响其他组件样式。编译时，形成局部作用域的css选择器，自动追加target属性。 3. 局部注册无需每个组件都注册到全局。通过vue组件components属性，在其作用域注册局部组件，从而形成一个组件树。 123456789101112131415&lt;template&gt; &lt;div id="app"&gt; &lt;sidebar /&gt; &lt;div id="routerview"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;//在app组件中声明components属性，通过import延迟加载引入子组件，并定义组件对应的标签名称。 components：&#123; sidebar:() =&gt; import("@/views/Sidebar")&#125;&#125;;&lt;/script&gt; 延迟加载组件 在原单页面开发中，将所有组件统一编译打包，在用户首次请求时全部响应给客户端。由于将用户当前还无需使用的代码全部返回，致使首屏加载显示过慢。 当声明为延迟加载组件，在编译时将编译为独立文件，在组件真正渲染时，下载相应组件文件渲染，可极大的增加互交体验。 三、Router 基于Vue实现组合组件从而组成应用。 基于vue-router实现SPA(single page application)应用。即，由vue-router在同一html页面显示不同的组件，实现单页面应用。也就是说，当vue-router实现当请求地址改变时，将什么组件渲染到什么地方。 vue工程中，默认的路由文件，src/router.js。可用@，代表src。 1. &lt;router-link&gt;​在具有路由功能的应用中（点击）导航。通过to属性指定目标地址，默认渲染成&lt;a&gt;​标签。可以通过配置tag属性生成别的标签，例如&lt;li&gt;​。 1&lt;router-link to="/example01"&gt;Helloword&lt;/router-link&gt; 2. &lt;router-view&gt;渲染路径匹配到的视图组件。支持内嵌&lt;router-view&gt;​，根据嵌套路径，渲染嵌套组件。 123456789101112131415//route.jsimport Vue form "vue";import Router from "vue-router";vue.use(Router);export default new Router (&#123; routes: [ &#123; //声明路由规则的路由路径 path: "/example01"; //路由的组件（延迟加载） component: () =&gt; import("@/views/example01/Example01.vue") &#125; ]&#125;); 三、MVVM-数据驱动 MVVM是数据驱动的，需要将MVVM中的视图内容，绑定VM中的数据。即，需要通过在data()方法返回值中声明属性，从而实现响应性数据的声明。（当一个Vue的实例被创建时，data()方法返回值中声明的属性，自动为vue响应式属性） 响应式数据：当这些属性的值发生改变时，视图将会产生“响应”，自动更新组件模板中的值。 vue组件中的data()，必须是一个函数。 只有在data() return中预定义的属性才支持响应式更新；因此即使当前不使用，而以后使用的属性，也必须提前定义，但可先置空引用null。 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &lt;h1&gt;Data() Return&lt;/h1&gt; &#123;&#123; msg &#125;&#125; //双大括号，引用data() return中声明的属性 &lt;button @click="changeMsg"&gt;change msg&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;/*注意data是方法，有括号，在return中声明响应式数据。-----可简写return方法-----data：（）=&gt; (&#123; msg: "你好" &#125;)，*/ data() &#123; return &#123; msg: "你好" &#125;； &#125;， methods: &#123; //重新赋值，感受响应式数据的自动响应更新。即当数据改变，视图中的内容将同步更新。 changeMsg() &#123; //必须使用this关键字，声明为当前vue对象的引用。 this.msg = "Hello Word!"; &#125;, &#125;&#125;&lt;/script&gt; 四、实例生命周期回调函数vue组件实例生命周期回调函数。每个vue实例在被创建时，都要经过一系列的初始化过程。在这个过程中，会回调生命周期函数，这给了用户在组件不同阶段添加自己代码的机会。 在默认状态，切换组件时，组件都会重新创建和销毁。例如：当组件1切换到组件2时，先创建2并达到挂载前状态，销毁组件1，然后挂载组件2。 在底层实现上，vue将模板编译成虚拟DOM渲染，基于虚拟DOM完成所有操作后将最终的结果挂载到真实的DOM上。]]></content>
      <categories>
        <category>System Design</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>components</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture14]]></title>
    <url>%2F2019%2F05%2F01%2FLecture14%2F</url>
    <content type="text"><![CDATA[Lecture 14一、Timer Service 定时服务（timer service)：用以调度安排所有基于定时通知的工作流程。 支持指定时间、某一时间后、指定时间间隔内的定时通知 Spring Task Execution and Scheduling 基于TaskExecutor，TaskScheduler接口 基于注释 基于Quartz Scheduler第三方库 1. 相关注释 @EnableScheduling。启动定时任务，Springboot默认不自动启动定时任务。 @Scheduled。cron表达式，指定执行时间表达式。 Cron表达式由6到7项组成。顺序是：秒、分、时、日、月、星期（数字或单词缩写）、年（可省略，即表示每年）。各项值为数字或符号，可使用相关正则表达式。 eg：@Scheduled(cron = &quot;0 0 8-17 * * 1-5&quot;) 表示每周周一到周五，8点至17点定时执行某任务。 二、Model-View-ViewModel (MVVM) ViewModel，协助处理显示逻辑 将V中的显示内容，与VM中的数据绑定。当VM中的数据发生变化时，通知V同步更新显示数据。 以往实现的是同步更新，即当数据发生变化时，重写获取整个HTML页面。而对于单页面应用，采取的是异步的方式，仅在初始请求时，获取整个HTML页面，之后仅需获取json格式的所需数据。 三、前端1. React框架 提出前端应基于组件化而非模板化的设计思想，打破原web开发内容/行为/样式分离的原则。 提出虚拟DOM，极大的提高了浏览器更新的DOM节点的速度。 组件化就是vue将前端的html+css+js文件都放到一个文件中 .vue里面。封装格式如下 HTML （结构）：被VUE封装在&lt;template&gt;​中， CSS（样式）：对应&lt;style&gt;​ JavaScript：对应&lt;script&gt;​ 2. Vue框架 用于构建直观的、快速和组件化交互界面的MVVM框架。 基于虚拟DOM，关注视图。 3. Webpack webpack，前端资源模块化管理打包工具。可以将松散的模块，按照依赖和规则打包成符合生产环境部署的前端资源。支持按需异步加载模块，支持基于部署调试不同环境的编译打包。 Vue工程中创建的vue组件文件(.vue)，通过webpack打包为生产环境文件。即将每一个组件文件中的，HTML、CSS、JS代码分离，合并。将工程资源、第三方资源（图片，JS文件，CSS文件等）按配置归类，编译打包。 ​ 4. Vue/cli Vue/cli，vue的手脚架工具，用于构建工程结构，本地调试，代码部署，热加载和单元测试等。 协助构建继承vue，vue-router，ESLint，TS等项目的工具。 自动创建vue工程所需依赖的配置文件，并在构建后自动下载依赖。 自动创建webpack配置，基于webpack打包编译项目为可执行部署的前端应用。 支持GUI界面的项目构建/插件/依赖等管理。 $ps$：ESLint，按ES规范，检查JS代码的工具，用于统一开发代码风格。]]></content>
      <categories>
        <category>System Design</category>
      </categories>
      <tags>
        <tag>Timer Server</tag>
        <tag>MVVM</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lecture12]]></title>
    <url>%2F2019%2F05%2F01%2Flecture12%2F</url>
    <content type="text"><![CDATA[$Lecture12 (Security)$一、加密/解密算法 加密算法\begin{cases} 对称算法 （两端通过密钥均可解密，加密和解密使用同一个密钥）\\ \\ 非对称算法（一端通过公钥加密的数据，另一端必须通过对应的私钥才能解密）\end{cases}1. 哈希算法1. 1 特性 不可逆性*。通过哈希算法转换的数据是唯一的，无法再转换回原始数据，因此哈希算法不能称为加密/解密算法(无法解密)。 压缩性。任意长度的数据，算出的$MD5$值的长度是固定的（是一个$128bits$ 16进制的字符串，32长度）。 抗修改性。对原数据的任何改动，即使仅修改一个字节生成的值也会完全不同。和第一条的转换唯一性是对应的。 强抗碰撞。加强对哈希算法是伪造数据非常困难。 易计算。从原数据计算出值很容易。 1.2 缺陷​ 由于唯一明文计算得到唯一散列值，因此可通过预先创建的彩虹表数据库，对比验证弱密码。 1.3 改进 在明文后追加“盐”值，从而使通过撞库成功获取的值也不是用户的原始密码。验证时，将密码加上盐值后，计算哈希值与保存的哈希值进行比对。 但是，为了安全不能使用全局盐值，需要为每个用户保存独立的盐值。 二、SecuritySpring提供了一套安全框架，处理加密/解密数据信息。包括对称/非对称，不同哈希算法等一系列实现。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-crypto&lt;/artifactId&gt;&lt;/dependency&gt; $ps:$ 基于$springboot$时，parent中默认声明类spring各框架版本，因此不必声明版本。 1. PasswordEncoder接口12String encode(CharSequence rawPassword) //编码密码boolean matches(CharSequence rawPassword, String encodedPassword) //验证原始密码与编码密码 1.1 $Pbkdf2PasswordEncoder$类($Pbkdf2$算法)​1.2 $BCryptPasswordEncoder$类$Bcrypt$算法，自动生成随机盐值，并附在结果，避免盐值的单独保存。 1234PasswordEncoder p = new BCryptPasswordEncoder();String password = "123456";String result = p.encode(password);p.matches("123456", result); 两算法均为针对并发破解的算法，可极大的增加破解的时间复杂度。 2. Encryptors Spring-Security提供基于256-bit $Pbkdf2$对称算法的实现。 提供不可泄露的加密密钥$SecretKey$。 基于不可泄露的16-byte长度的盐值。 $TextEncryptor \quad Encryptors.text(secretKey, salt)$基于指定密钥和盐值创建文本加密器。 $String \quad encrypt(payload) $加密指定字符串 $String \quad decrypt(encryptString)$ 解密指定字符串 使用密钥和盐值创建加密器时，在application.properties中，声明密钥和盐值。 12my.secretkey=R28K4ZEJ8LWRHU5my.salt=636eac2543bcfcb0 利用value注解，结合$SpEL$表达式，支持直接将properties中配置注入 1234@Value("$&#123;my.secretkey&#125;")private String secretKey;@Value("$&#123;my.salt&#125;")private String salt; 三、Jackson $ObjectMapper$类 Jackson是一个简单基于Java应用库，Jackson可以轻松的将Java对象转换成json对象和xml文档。同样也可以将json、xml转换成Java对象。Jackson所依赖的jar包较少，简单易用并且性能也要相对较高。 $SpringMVC$默认基于Jackson实现序列化和反序列化。 $SpringMVC$自动注入Jackson的序列化$ObjectMapper$对象到容器中。 String $writeValueAsString$(T payload)，将对象序列化为$json$字符串。 T $readValue$（String content, Class c)，将$json$字符串反序列化为指定类型的$java$对象 建议将所有的$json$反序列化为Map 123456789101112131415161718192021222324252627@Component //创建可复用的序列化组件public class ObjectMapperComponent &#123; @Autowired //自动注入容器中的jackson组件 private ObjectMapper mapper; public String writeValueAsString(Map payload) &#123; try &#123; //将Map对象序列化为json字符串 return mapper.writeValueAsString(payload); &#125; catch(JsonProcessingException e) &#123; &#125; return null; &#125; public Map&lt;String, Object&gt; readValue(String json) &#123; try &#123; //将json字符串反序列化为Map对象 return mapper.readValue(json, Map.class); &#125; catch(IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125; 四、ResponseStatusException $SpringMVC5$提供的，支持直接基于HTTP状态码抛出异常 12new ResponseStatusException(HttpStatus.UNAUTHORIZED, "未登录！")new ResponseStatusException(HttpStatus.FORBIDDEN, "无权限！") 提供自定义支持声明状态码的未登录异常 123456public static final String UNAUTHORIZED = "未登录"；public static final String LOGIN_ERROR = "用户密码错误"；public UnauthorizedException(String reason) &#123; super(HttpStatus.UNAUTHORIZED, reason);&#125; 综合上述知识点，创建加密和解密组件 1234567891011121314151617181920212223@Componentpublic class EncryptorComponent05 &#123; @Value("$&#123;my.secretkey&#125;") private String secretKey; @Value("$&#123;my.salt&#125;") private String salt; @Autowired private ObjectMapperComponent oComponent; //序列化组件 //加密 public String encrypt(Map payload) &#123; String json = oComponent.writeValueAsString(payload); return Encryptors.text(secretKey, salt).encrypt(json); &#125; //解密 public Map&lt;String, Object&gt; decrypt(String encryptString) &#123; try &#123; String json = Encryptors.text(secretKey, salt).decrypt(encryptString); return oComponent.readValue(json); &#125; catch (Exception e) &#123; throw new UnauthorizedException(); &#125; &#125;&#125; 五、Interceptors（拦截器）1. $HandlerInterceptorAdapter$抽象类 Boolean $preHandle()$方法，controller方法执行前回调。登录验证等。 Void $postHandle()$方法，$preHandler()$返回true后，controller方法执行后，视图渲染前，回调，统一视图。 $afterCompletion$方法，$postHandle()$执行后，视图渲染后，回调。统一异常处理，统一日志处理等。 Object handle，封装被拦截方法对象。 12345678@Component //声明一个拦截器组件public class Myinterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; log.debug("preHandle()"); return true; &#125;&#125; 2. 拦截器的使用创建一个实现了$WebMvcConfigure$接口的配置类，重写相关方法声明注册拦截器等组件。123456789101112@Configuration //声明为配置类public class WebMvcConfig implements WebMvcConfigure &#123; @AutoWired private Myinterceptor myinterceptor; @Override //该方法自动注入拦截器注册对象InterceptorRegistry，可声明多个拦截器，按顺序拦截。 public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(myinterceptor) //添加拦截器组件 .addPathPatterns("/api/example05/**") //添加拦截路径 .excludePathPatterns("/api/example05/login"); //添加排除路径 &#125;&#125; 完整实例登录时，获取用户信息并加密置于响应中 12345678910111213141516171819@AutoWiredprivate EncryptorComponent05 encryptorComponent;@PostMapping("/login")//@RequestBody主要用来接收前端传给后台的json字符串中的数据(请求体中的数据)public void login(@RequestBody Map&lt;String, String&gt; user, HttpServletResponsen response) &#123; if ("BO".equals(user.get("userName"))) &#123; //模拟登陆成功，将用户身份信息封装到Map Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("uid", 1); map.put("aid", 1); //生成加密token，将Map对象加密为字符串 String token = encryptorComponent.encrypt(map); log.debug(token); //在header创建自定义的权限，将加密的token以自定义属性置于响应的header response.setHeader("Authorization", token); &#125; else &#123; throw new UnauthorizedException(); &#125;&#125; 该用户继续访问时，从相应中获取并解密用户信息 1234567891011121314151617181920212223@Componentpublic class LoginInterceptor05 extends HandlerInterceptorAdapter &#123; @Autowired private EncryptorComponent05 encryptorComponent; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; //从header获取自定义属性 //optional.ofNullable(T value)根据传入的参数来构造一个optional，传入的参数可以为null，当参数为null时，返回一个空的optional。 //or方法的作用是，如果一个optional包含值，则返回自己；否则，返回由参数产生的另一个optional对象。 //map（……）当optional不为空的时候返回一个新的optional,其中包含输入参数产生的输出值。 //orElse，如果optional中有值将其返回，否则返回orElse方法传入的参数。 return Optional.ofNullable(request.getHeader("Authorization")) .or(()-&gt;&#123; throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "未登录！"); &#125;) .map(token -&gt; &#123; var map = encryptorComponent.decrypt(token); request.setAttribute("uid", Integer.valueOf(map.get("uid").toString())); request.setAttribute("aid", Integer.valueOf(map.get("aid").toString())); &#125;) .orElse(false); &#125;&#125;]]></content>
      <categories>
        <category>System Design</category>
      </categories>
      <tags>
        <tag>Encryptors</tag>
        <tag>Security</tag>
        <tag>Interceptors</tag>
        <tag>Object Serialization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlabGexe]]></title>
    <url>%2F2019%2F05%2F01%2FmatlabGexe%2F</url>
    <content type="text"><![CDATA[MATLAB打包成可执行文件(.exe)我在完成这个事情时，在网上翻阅了很多资料，发现介绍16版本以上的大有人在。所以本篇主要是以我目前使用的$2012b$版本来介绍，给需要的人以参考。 1. 启动工具箱可以直接用命令行deploytool调用，也可以直接在工具栏查找$MATLAB \quad Complier$，如下图： 启动工具箱之后，界面如图所示： 因为我要将我写的GUI程序打包成exe，所以在这里选择了第一项，并重命名为Analysis.prj。（好像说Name这里要用英文开头的名字，大家注意一下）。这里选择的位置就是生成Analysis_pkg.exe程序的文件位置。 2. 指定部署文件在第一步完成之后，在左侧会出现一个如下图界面。在Main File中添加执行的主文件（我这添加的就是第一步执行的程序文件）。在下面的界面中添加其余的依赖文件（我这里添加的是第一步执行完调用的第二步的程序） 点击Package，进入Package选项卡。点击右下角的Add MCR，出现如图界面。选择第一个在package中嵌入MCR。这样生成的文件就能运行在没有安装MATLAB的机器上运行了。 3. 打包所有步骤都完成之后，点击第二个Package，进行打包。 4. 生成在当前目录下生成相应的文件夹，其中含有如下两个子文件夹。 5. 其他还有就是在你之前选定的文件夹中，会生成Analysis_pkg.exe。对于没有安装MCR（Matlab Complier Runtime）的环境（其实安没安装都可以直接拿走这几文件就行了）只需要这个文件就行，点击该可执行文件会先引导安装MCR，接着会生成正式程序的可执行文件。]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab generate exe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229(三) - 多变量线性回归]]></title>
    <url>%2F2019%2F05%2F01%2Fml3%2F</url>
    <content type="text"><![CDATA[一、假设函数与梯度下降1.1 假设函数在之前的单变量线性回归中，只涉及到一个特征，所以假设函数为： h_\theta(x) = \theta_0+\theta_1x对于多变量来说，类似地可得假设函数： h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_2+...+\theta_nx_n观察这个假设函数，我们可以发现这是向量內积的表现形式，因此我们可以对其进行简化表示。首先定义$x_0=1$，则此时假设函数为： h_\theta(x)=\theta_0x_0+\theta_1x_1+\theta_2x_2+...+\theta_nx_n再令： \theta=\begin{bmatrix} \theta_0\\ \theta_1\\ \theta_2\\ .\\ .\\ .\\ \theta_n \end{bmatrix},\quad\quad\quad\quad\quad\quad x=\begin{bmatrix} x_0\\ x_1\\ x_2\\ .\\ .\\ .\\ x_n \end{bmatrix}这样就得到了假设函数的向量表示： h_\theta(x)=\theta_0x_0+\theta_1x_1+\theta_2x_2+...+\theta_nx_n=\theta^Tx1.2 梯度下降算法 repeat\ until \ convergence\ \{\\ \theta_j :=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^m{h_\theta(x^{(i)}-y^{(i)})x_j^{(i)}}\\ (simultaneously \ update \ \theta_j \ for \ j=0,...,n)\\ x^{(i)}_j中的i表示整个数据集中的第i个样本数据，j表示在第i个样本数据中的第j个特征的值\ \}在具体编程实现时，上述公式的代码实现如下。其中$\theta$为行向量；$X$为数据集矩阵，每一行为一个数据集中的一个样本数据；y为输出对象的数据集。 \theta = \theta - \alpha*(1/m)*X'*(X*\theta-y)二、特征处理2.1 特征缩放 (Feature Scaling) 引言：在多变量线性回归中，如果每个特征的取值范围相差很大，那么在梯度下降算法的执行就会很慢。而当各个特征值的取值范围相近时，梯度下降算法就能快速的收敛到最小值。 方法： 所以在进行梯度下降之前，首先对数据做特征缩放处理。从而使得各特征的取值都在相近的数据范围内。因为$x_0=1$，所以其余的特征缩放到$[-1, 1]$之间是比较理想的。 2.2 均值归一化(Mean normalization)均值归一化是特征缩放的方法之一。 x_i = \frac{x_i-\mu_i}{s_i} \\ (\mu_i是x_i数据的均值，s_i是x_i数据的最大值与最小值之差或者标准差)特征缩放不需要特别准确的缩放到某一范围，只要使得各数据的范围相近就行。 三、代价函数与学习率 引言：在运行梯度下降算法时，学习率的大小一般是通过尝试不同的值($eg: \ …,\ 0.001,\ 0.003,\ 0.01,\ 0.03,\ 0.1, \ 0.3,\ 1,….)$的方式来找到一个适合当前问题的学习率。 方法1：我们可以通过画出代价函数与迭代次数的曲线图来观察梯度下降的运行。从而判断此时的梯度下降算法是否能收敛。 如图，横坐标轴代表迭代次数，纵坐标代表代价函数值。该图展示的是梯度下降的每部迭代后，代价函数的值。这是当梯度函数正常运行是的一种曲线图，因为每一步迭代之后代价函数都在减少。同时，我们可以看到当迭代到达300之后，代价函数的值变化很小，400次后就近乎收敛了。 方法2：自动收敛测试。即，每次迭代之后观察$J(\theta)$的值；如果迭代之后下降的值小于$\epsilon$（$eg：\epsilon = 10^{-3}$)就判定为收敛。但是准确地选择阈值$\epsilon$是非常困难的，所以该方法不常用。 结论：数学家已经证明，对于线性回归问题，只要学习率足够小，每次迭代之后代价函数都会下降。因此代价函数如果没有下降，那可能是学习率太大。当然学习率也不能太小，否则下降的速度会很慢。 四、特征选择与多项式回归1. 特征选择对于问题所给出的特征，我们不一定就是直接利用现有的特征构造模型。我们可以根据情景，利用现有的特征进行组合构造出更适合的特征，构造更准确的模型。 假设预测房屋价格, 提供房屋的长和宽作为变量, 得到如下的假设函数： h_(\theta) = \theta_0+\theta_1*frontage+\theta_2*depth\\ (frontage是指临街的宽度，depth是指纵深)但是我们可以自己创造特征，利用面积去预测房价： h_(\theta) = \theta_0+\theta_1x\\ (x是frontage与depth的乘积) 2. 多项式回归(Polynomial Regression)和特征选择密切相关的一个概念就是多项式回归。 假设有如下的住房价格的数据集，可能会有多个不同的模型用于拟合。 根据房价和土地大小的性质，这里用三次多项式进行拟合会是较适合的一种情况。 h_\theta(x)=\theta_0+\theta_1(size)+\theta_2(size)^2+\theta_3(size)^3但是如何将模型与数据拟合呢？我们可以使用多元线性回归的方法。 h_\theta(x)=\theta_0+\theta_1x+\theta_2x_2+\theta_3x_3比较两式子，我们可以通过将x1设为$(size)$，x2设为$(size)^2$，x3设为$(size)^3$实现两式的对应。再利用已学的多元线性回归知识，最终将一个三次函数拟合到数据集上。在这一过程，我们就能发现特征缩放的重要性。 根据对平方根函数的了解，也可以选择平方根函数模型 h_\theta(x)=\theta_0+\theta_1(size)+\theta_2\sqrt[2]{(size)} 五、正规方程1. 正规方程之前我们一直用的是梯度下降求解最优解，在于的缺点在于需要进行多次迭代才能得到全局的最优解。而正规方程提供了一种解析方法，一次性（一步）求解，不需要迭代。 现有一个代价函数：$J(\theta)=a\theta^2+b\theta+c\ (\theta \in R)$。如何最小化该函数呢？ 我们对该函数求导，并令导数等于0，就可求得使$J(\theta)$最小的$\theta$值。 当$\theta \in R^{n+1}$，即$\theta$为向量时；代价函数是这个向量的函数：$ J(\theta0, \theta_1,…,\theta_m) =\frac{1}{2m}\sum{i=1}^m{h_\theta(x^{(i)}-y^{(i)})^2}$，要最小化该函数，我们需要对每一个变量求偏导并令等式等于0。从而求出每一个值，能是的该函数最小。 设计矩阵X：矩阵的每一行是所有特征的一个样本数据$(x^{(0)}_i,x^{(1)}_i,…,x^{(m)}_i)$，上标$(0,…,m)$表示特征的序列，下标$i$表示矩阵的第$i$行，第$i$个样本数据。注意这里$x^{0}_i$恒为1。 目标对象样本向量y：$y =\begin{bmatrix} y1 \ y2 \ .\ .\ .\ y_n\end{bmatrix}$ 正规方程计算公式： \theta=(X^TX)^{-1}X^Ty\\ X\theta=y,\ (X^TX)是为了将X转为方阵这样计算出最优的$\theta$，其能最小化这个代价函数。同时，使用正规方程计算时，不用考虑特征缩放问题。 2. 正规方程与梯度下降的比较 梯度下降 正规方程 需要寻找合适的学习率 不需要学习率 当特征量小时，需要进行多次迭代 特征量小时，一次计算求得，优于梯度下降 当有大量特征时，依然能适用 当特征量大时，矩阵维度很大，运算$(X^TX)^{-1}$很慢 对于后续的复杂算法，如$logistic$分类算法，正规方程不适用。 六、Octaveoctave中定义的函数能返回多个值。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Linear Regression</tag>
        <tag>Multiple linear Regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229(二) - 单变量线性回归]]></title>
    <url>%2F2019%2F04%2F07%2Fml2%2F</url>
    <content type="text"><![CDATA[一、假设函数当使用某种学习算法对训练集的数据进行训练时，学习算法的任务就是输出一个函数。这个我们称为假设函数(Hypothesis Function)。在线性回归问题中这个函数就是对训练集中数据的拟合函数。假设函数以特征为输入，以预测值（标记）为输出。 单变量线性回归的假设函数定义如下： h_{\theta} = \theta_{0} + \theta_{1}x二、代价函数2.1 定义我们知道了假设函数的形式之后，就要去寻找合适的 $\theta{0}$和$\theta{1}$的值，使得假设函数尽量地符合训练集。为了描述这种贴切程度，我们使用代价函数来衡量假设函数的准确性。在这里我们选择均方误差来作为衡量标准，即我们想要每个样例的估计值与真实值之间差的平方均值最小。用公式表达如下： minmize\frac{1}{2m}\sum_{i=0}^m(h_\theta(x^i) -y^i)^2(可以发现这很类似于最小二乘法的公式，这里稍有不同的就是分母多了个2，这个2是为了便于后续的求偏导计算)。我们记： cost \ function: \ J(\theta_{0},\theta_{1}) = \frac{1}{2m}\sum_{i=0}^m(h_\theta(x^i) -y^i)^2这就得到我们的代价函数(cost function)，也是我们的目标函数。我们想要目标函数最小，即： Goal: \ minmize _{\theta_{0},\theta_{1}}J(\theta_{0},\theta_{1})2.2 代价函数图根据一个给定的训练集绘制出$\theta{0}$、$\theta{1}$和代价函数值的图像。我们可以知道是一个三维的碗状图。为了更好的展示图形，我们使用等高线图（contour plot）来展示三维曲面图。等高线图的横轴坐标分别表示$\theta0$和$\theta_1$，图中的每一个椭圆代表$J(\theta{0},\theta_{1})$值相等的点。 三、梯度下降算法(Gradient descent algorithm )我们得出假设函数和代价函数之后，希望有特定的算法能帮助我们找到最佳的假设函数$h_\theta(x)$，即找到代价函数的最小值。因此，我们引入梯度下降算法。 3.1 相关概念 梯度：梯度是一个向量，是可微函数$z = f(x, y)$在点$(x, y)$处取得最大方向导数的方向。即沿梯度方向的方向导数达到最大，也就是说，梯度的方向是函数在这点增长最快的方向。梯度的模为方向导数的最大值。 方向导数：函数在某一点的一个特定方向上的曲线斜率。 梯度下降算法是一种优化算法，它可以帮助我们找到一个函数的极小值点。它不仅可用在线性回归问题中，在其他机器学习模型中也常使用。 梯度下降的过程可以通俗地理解为随机地站在山坡上的某一点（随机的初始化值，如初始化为0）下山坡，如果想要尽可能快地下坡，每次都应该沿着坡度最大的方向下山。由此可见，梯度下降算法最终得到的结果会受初始值的影响，即当从不同的位置开始，可能到达不同的局部最小值（对于凸函数，会收敛到最小值）。 3.2 定义梯度下降算法就是不断地同步更新假设函数中的所有待定参数，使得代价函数的函数值不断减小，直至收敛（即多次更新，代价函数的函数值不再改变或是在一个阈值内波动）。公式如下： repeat\ until \ convergence\ \{\\ \theta_j :=\theta_j-\alpha\frac{\partial}{\partial \theta_j}J(\theta_0, \theta_1) \quad (simultaneously \quad update)\\ \}在该公式中$:=$表示赋值符号。$\theta$叫做学习率，用来控制下降的幅度。$\frac{\partial}{\partial \theta_j}J(\theta_0, \theta_1)$就是梯度。对于同步更新的理解，举例如下： temp0 := \theta_0-\alpha\frac{\partial}{\partial \theta_0}J(\theta_0, \theta_1) \\ temp1 := \theta_1-\alpha\frac{\partial}{\partial \theta_1}J(\theta_0, \theta_1) \\ \theta_0 := temp_0 \\ \theta_1 := temp_13.3 梯度和学习率在梯度下降算法中，我们根据梯度的概念，使用的是梯度相反的方向，即函数下降最快的方向。这也是我们更新的方向。 学习率$\alpha$会影响梯度下降的幅度。如果$\alpha$太小，则$\theta$的更新速度会很缓慢；相反，如果$\alpha$太大，则在更新的过程中。可能直接越过最低点，导致永远没法到达最低点。 在更新的过程中，由于是沿着下降的方向更新，则我们可以知道：越接近最低点，梯度的值就越小。这样在每次的更新的过程中，下降的程度就会越小。所以不用在每次更新的过程中减小$\alpha$来减少下降程度，只要在初始选定一个恰当的值即可。 学习率的确定 在运行梯度下降算法时，学习率的大小一般是通过尝试的方式来选取一个适合当前问题的学习率。在判断一个学习率是否适合时，我们可用代价函数-迭代次数图作为依据。若代价函数值随迭代次数的增加而减少并最终收敛，则说明该值可作为候选值。（对于线性回归问题，只要学习率足够小，代价函数值总会随着迭代而减少） 3.4 梯度下降算法运用将我们之前线性回归中的代价函数代入梯度下降算法中，就得到了线性回归算法： repeat\ until \ convergence\ \{\\ \theta_0 :=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^m(h_{\theta(x^i)}-y^i) \\ \theta_1 :=\theta_1-\alpha\frac{1}{m}\sum_{i=1}^m(h_{\theta(x^i)}-y^i)x^i\\ \}$ps:$ 在机器学习的公式表示中，$x^i$等同于我们平常的$x_i$，而不是幂次的意思，表示第$i$个样本数据。 线性回归中的代价函数总是凸函数(convex function)，所以总会收敛到全局最优解。因为没有其他的局部最优解。 3.5 总结梯度下降算法三要素：出发点（初始值）、下降方向（梯度）、下降步长（学习率）。 梯度下降算法又称为Batch梯度下降算法，这是因为在每一次梯度下降的过程中，我们都遍历了整个训练集中的样本（由代价函数的定义易知）。 事实上，梯度下降算法更适合于更大数据集的情况。对于规模较小的数据集，不需要多次迭代来求解，还有一种叫正规方程组法的方法更适合。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Coursera</tag>
        <tag>Linear Regression</tag>
        <tag>cost function</tag>
        <tag>Gradient descent algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229(一) - 监督学习和无监督学习]]></title>
    <url>%2F2019%2F04%2F06%2Fml1%2F</url>
    <content type="text"><![CDATA[一、监督学习(supervised learning)1.1 监督学习定义百度百科定义如下： 监督学习是指：利用一组已知类别的样本调整分类器的参数，使其达到所要求性能的过程，也称为监督训练或有教师学习。 监督学习是从标记的训练数据来推断一个功能的机器学习任务。训练数据包括一套训练示例。在监督学习中，每个实例都是由一个输入对象（通常为矢量）和一个期望的输出值（也称为监督信号）组成。 从数据的角度上区分，监督学习与无监督学习的区别就在于监督学习的数据不仅仅由特征组成，还包含一个准确的输出值。即监督学习的样本集中的数据都带有标签（标记）。 1.2 监督学习分类在监督学习中我们的预测值即可以是离散值，又可以是连续值。我们根据这一属性可将监督学习分为回归问题(Regression)和分类问题(Classification)。 监督学习\begin{cases} 回归问题\\ \\ 分类问题 \end{cases} 对于肿瘤数据来说，其标记有两种：1，0。1代表该肿瘤是恶性的，0代表该肿瘤是良性。此类问题就是监督学习中的分类问题。 对于房价预测问题，我们要根据某些特征（如面积等）来预测房价。那么数据这时的标记就是房价了，而我们知道房价是实数，是连续的，不能用某些特定的值来囊括。那么这类问题就是监督学习中的回归问题了。 二、无监督学习(unsupervised learning)2.1 无监督学习定义无监督学习就是训练集中的样本没有标记，或者说全部具有相同的标记。即不知道所给的数据集中都有哪些类别。 无监督学习主要是研究聚类问题。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>supervised learning</tag>
        <tag>unsupervised learning</tag>
        <tag>Coursera</tag>
      </tags>
  </entry>
</search>
